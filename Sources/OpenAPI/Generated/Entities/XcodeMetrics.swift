// Generated by Create API
// https://github.com/CreateAPI/CreateAPI

import Foundation

public struct XcodeMetrics: Codable {
	public var productData: [ProductDatum]?
	public var version: String?
	public var insights: Insights?

	public struct ProductDatum: Codable {
		public var metricCategories: [MetricCategory]?
		public var platform: String?

		public final class MetricCategory: Codable {
			public let identifier: AppStoreConnect_Swift_SDK.MetricCategory?
			public let metrics: [Metric]?

			public struct Metric: Codable {
				public var unit: Unit?
				public var datasets: [Dataset]?
				public var identifier: String?
				public var goalKeys: [GoalKey]?

				public struct Unit: Codable {
					public var identifier: String?
					public var displayName: String?

					public init(identifier: String? = nil, displayName: String? = nil) {
						self.identifier = identifier
						self.displayName = displayName
					}

					public init(from decoder: Decoder) throws {
						let values = try decoder.container(keyedBy: StringCodingKey.self)
						self.identifier = try values.decodeIfPresent(String.self, forKey: "identifier")
						self.displayName = try values.decodeIfPresent(String.self, forKey: "displayName")
					}

					public func encode(to encoder: Encoder) throws {
						var values = encoder.container(keyedBy: StringCodingKey.self)
						try values.encodeIfPresent(identifier, forKey: "identifier")
						try values.encodeIfPresent(displayName, forKey: "displayName")
					}
				}

				public struct Dataset: Codable {
					public var points: [Point]?
					public var filterCriteria: FilterCriteria?
					public var recommendedMetricGoal: RecommendedMetricGoal?

					public struct Point: Codable {
						public var version: String?
						public var percentageBreakdown: PercentageBreakdown?
						public var value: Double?
						public var errorMargin: Double?
						public var goal: String?

						public struct PercentageBreakdown: Codable {
							public var value: Double?
							public var subSystemLabel: String?

							public init(value: Double? = nil, subSystemLabel: String? = nil) {
								self.value = value
								self.subSystemLabel = subSystemLabel
							}

							public init(from decoder: Decoder) throws {
								let values = try decoder.container(keyedBy: StringCodingKey.self)
								self.value = try values.decodeIfPresent(Double.self, forKey: "value")
								self.subSystemLabel = try values.decodeIfPresent(String.self, forKey: "subSystemLabel")
							}

							public func encode(to encoder: Encoder) throws {
								var values = encoder.container(keyedBy: StringCodingKey.self)
								try values.encodeIfPresent(value, forKey: "value")
								try values.encodeIfPresent(subSystemLabel, forKey: "subSystemLabel")
							}
						}

						public init(version: String? = nil, percentageBreakdown: PercentageBreakdown? = nil, value: Double? = nil, errorMargin: Double? = nil, goal: String? = nil) {
							self.version = version
							self.percentageBreakdown = percentageBreakdown
							self.value = value
							self.errorMargin = errorMargin
							self.goal = goal
						}

						public init(from decoder: Decoder) throws {
							let values = try decoder.container(keyedBy: StringCodingKey.self)
							self.version = try values.decodeIfPresent(String.self, forKey: "version")
							self.percentageBreakdown = try values.decodeIfPresent(PercentageBreakdown.self, forKey: "percentageBreakdown")
							self.value = try values.decodeIfPresent(Double.self, forKey: "value")
							self.errorMargin = try values.decodeIfPresent(Double.self, forKey: "errorMargin")
							self.goal = try values.decodeIfPresent(String.self, forKey: "goal")
						}

						public func encode(to encoder: Encoder) throws {
							var values = encoder.container(keyedBy: StringCodingKey.self)
							try values.encodeIfPresent(version, forKey: "version")
							try values.encodeIfPresent(percentageBreakdown, forKey: "percentageBreakdown")
							try values.encodeIfPresent(value, forKey: "value")
							try values.encodeIfPresent(errorMargin, forKey: "errorMargin")
							try values.encodeIfPresent(goal, forKey: "goal")
						}
					}

					public struct FilterCriteria: Codable {
						public var device: String?
						public var percentile: String?
						public var deviceMarketingName: String?

						public init(device: String? = nil, percentile: String? = nil, deviceMarketingName: String? = nil) {
							self.device = device
							self.percentile = percentile
							self.deviceMarketingName = deviceMarketingName
						}

						public init(from decoder: Decoder) throws {
							let values = try decoder.container(keyedBy: StringCodingKey.self)
							self.device = try values.decodeIfPresent(String.self, forKey: "device")
							self.percentile = try values.decodeIfPresent(String.self, forKey: "percentile")
							self.deviceMarketingName = try values.decodeIfPresent(String.self, forKey: "deviceMarketingName")
						}

						public func encode(to encoder: Encoder) throws {
							var values = encoder.container(keyedBy: StringCodingKey.self)
							try values.encodeIfPresent(device, forKey: "device")
							try values.encodeIfPresent(percentile, forKey: "percentile")
							try values.encodeIfPresent(deviceMarketingName, forKey: "deviceMarketingName")
						}
					}

					public struct RecommendedMetricGoal: Codable {
						public var detail: String?
						public var value: Double?

						public init(detail: String? = nil, value: Double? = nil) {
							self.detail = detail
							self.value = value
						}

						public init(from decoder: Decoder) throws {
							let values = try decoder.container(keyedBy: StringCodingKey.self)
							self.detail = try values.decodeIfPresent(String.self, forKey: "detail")
							self.value = try values.decodeIfPresent(Double.self, forKey: "value")
						}

						public func encode(to encoder: Encoder) throws {
							var values = encoder.container(keyedBy: StringCodingKey.self)
							try values.encodeIfPresent(detail, forKey: "detail")
							try values.encodeIfPresent(value, forKey: "value")
						}
					}

					public init(points: [Point]? = nil, filterCriteria: FilterCriteria? = nil, recommendedMetricGoal: RecommendedMetricGoal? = nil) {
						self.points = points
						self.filterCriteria = filterCriteria
						self.recommendedMetricGoal = recommendedMetricGoal
					}

					public init(from decoder: Decoder) throws {
						let values = try decoder.container(keyedBy: StringCodingKey.self)
						self.points = try values.decodeIfPresent([Point].self, forKey: "points")
						self.filterCriteria = try values.decodeIfPresent(FilterCriteria.self, forKey: "filterCriteria")
						self.recommendedMetricGoal = try values.decodeIfPresent(RecommendedMetricGoal.self, forKey: "recommendedMetricGoal")
					}

					public func encode(to encoder: Encoder) throws {
						var values = encoder.container(keyedBy: StringCodingKey.self)
						try values.encodeIfPresent(points, forKey: "points")
						try values.encodeIfPresent(filterCriteria, forKey: "filterCriteria")
						try values.encodeIfPresent(recommendedMetricGoal, forKey: "recommendedMetricGoal")
					}
				}

				public struct GoalKey: Codable {
					public var goalKey: String?
					public var upperBound: Int?
					public var lowerBound: Int?

					public init(goalKey: String? = nil, upperBound: Int? = nil, lowerBound: Int? = nil) {
						self.goalKey = goalKey
						self.upperBound = upperBound
						self.lowerBound = lowerBound
					}

					public init(from decoder: Decoder) throws {
						let values = try decoder.container(keyedBy: StringCodingKey.self)
						self.goalKey = try values.decodeIfPresent(String.self, forKey: "goalKey")
						self.upperBound = try values.decodeIfPresent(Int.self, forKey: "upperBound")
						self.lowerBound = try values.decodeIfPresent(Int.self, forKey: "lowerBound")
					}

					public func encode(to encoder: Encoder) throws {
						var values = encoder.container(keyedBy: StringCodingKey.self)
						try values.encodeIfPresent(goalKey, forKey: "goalKey")
						try values.encodeIfPresent(upperBound, forKey: "upperBound")
						try values.encodeIfPresent(lowerBound, forKey: "lowerBound")
					}
				}

				public init(unit: Unit? = nil, datasets: [Dataset]? = nil, identifier: String? = nil, goalKeys: [GoalKey]? = nil) {
					self.unit = unit
					self.datasets = datasets
					self.identifier = identifier
					self.goalKeys = goalKeys
				}

				public init(from decoder: Decoder) throws {
					let values = try decoder.container(keyedBy: StringCodingKey.self)
					self.unit = try values.decodeIfPresent(Unit.self, forKey: "unit")
					self.datasets = try values.decodeIfPresent([Dataset].self, forKey: "datasets")
					self.identifier = try values.decodeIfPresent(String.self, forKey: "identifier")
					self.goalKeys = try values.decodeIfPresent([GoalKey].self, forKey: "goalKeys")
				}

				public func encode(to encoder: Encoder) throws {
					var values = encoder.container(keyedBy: StringCodingKey.self)
					try values.encodeIfPresent(unit, forKey: "unit")
					try values.encodeIfPresent(datasets, forKey: "datasets")
					try values.encodeIfPresent(identifier, forKey: "identifier")
					try values.encodeIfPresent(goalKeys, forKey: "goalKeys")
				}
			}

			public init(identifier: AppStoreConnect_Swift_SDK.MetricCategory? = nil, metrics: [Metric]? = nil) {
				self.identifier = identifier
				self.metrics = metrics
			}

			public init(from decoder: Decoder) throws {
				let values = try decoder.container(keyedBy: StringCodingKey.self)
				self.identifier = try values.decodeIfPresent(AppStoreConnect_Swift_SDK.MetricCategory.self, forKey: "identifier")
				self.metrics = try values.decodeIfPresent([Metric].self, forKey: "metrics")
			}

			public func encode(to encoder: Encoder) throws {
				var values = encoder.container(keyedBy: StringCodingKey.self)
				try values.encodeIfPresent(identifier, forKey: "identifier")
				try values.encodeIfPresent(metrics, forKey: "metrics")
			}
		}

		public init(metricCategories: [MetricCategory]? = nil, platform: String? = nil) {
			self.metricCategories = metricCategories
			self.platform = platform
		}

		public init(from decoder: Decoder) throws {
			let values = try decoder.container(keyedBy: StringCodingKey.self)
			self.metricCategories = try values.decodeIfPresent([MetricCategory].self, forKey: "metricCategories")
			self.platform = try values.decodeIfPresent(String.self, forKey: "platform")
		}

		public func encode(to encoder: Encoder) throws {
			var values = encoder.container(keyedBy: StringCodingKey.self)
			try values.encodeIfPresent(metricCategories, forKey: "metricCategories")
			try values.encodeIfPresent(platform, forKey: "platform")
		}
	}

	public struct Insights: Codable {
		public var trendingUp: [MetricsInsight]?
		public var regressions: [MetricsInsight]?

		public init(trendingUp: [MetricsInsight]? = nil, regressions: [MetricsInsight]? = nil) {
			self.trendingUp = trendingUp
			self.regressions = regressions
		}

		public init(from decoder: Decoder) throws {
			let values = try decoder.container(keyedBy: StringCodingKey.self)
			self.trendingUp = try values.decodeIfPresent([MetricsInsight].self, forKey: "trendingUp")
			self.regressions = try values.decodeIfPresent([MetricsInsight].self, forKey: "regressions")
		}

		public func encode(to encoder: Encoder) throws {
			var values = encoder.container(keyedBy: StringCodingKey.self)
			try values.encodeIfPresent(trendingUp, forKey: "trendingUp")
			try values.encodeIfPresent(regressions, forKey: "regressions")
		}
	}

	public init(productData: [ProductDatum]? = nil, version: String? = nil, insights: Insights? = nil) {
		self.productData = productData
		self.version = version
		self.insights = insights
	}

	public init(from decoder: Decoder) throws {
		let values = try decoder.container(keyedBy: StringCodingKey.self)
		self.productData = try values.decodeIfPresent([ProductDatum].self, forKey: "productData")
		self.version = try values.decodeIfPresent(String.self, forKey: "version")
		self.insights = try values.decodeIfPresent(Insights.self, forKey: "insights")
	}

	public func encode(to encoder: Encoder) throws {
		var values = encoder.container(keyedBy: StringCodingKey.self)
		try values.encodeIfPresent(productData, forKey: "productData")
		try values.encodeIfPresent(version, forKey: "version")
		try values.encodeIfPresent(insights, forKey: "insights")
	}
}
