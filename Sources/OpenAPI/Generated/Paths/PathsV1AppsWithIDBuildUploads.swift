// Generated by Create API
// https://github.com/CreateAPI/CreateAPI

import Foundation
import URLQueryEncoder

extension APIEndpoint.V1.Apps.WithID {
	public var buildUploads: BuildUploads {
		BuildUploads(path: path + "/buildUploads")
	}

	public struct BuildUploads {
		/// Path: `/v1/apps/{id}/buildUploads`
		public let path: String

		public func get(parameters: GetParameters? = nil) -> Request<AppStoreConnect_Swift_SDK.BuildUploadsResponse> {
			Request(path: path, method: "GET", query: parameters?.asQuery, id: "apps_buildUploads_getToManyRelated")
		}

		public struct GetParameters {
			public var filterCfBundleShortVersionString: [String]?
			public var filterCfBundleVersion: [String]?
			public var filterPlatform: [FilterPlatform]?
			public var filterState: [String]?
			public var sort: [Sort]?
			public var fieldsBuildUploads: [FieldsBuildUploads]?
			public var fieldsBuilds: [FieldsBuilds]?
			public var fieldsBuildUploadFiles: [FieldsBuildUploadFiles]?
			public var limit: Int?
			public var include: [Include]?

			public enum FilterPlatform: String, Codable, CaseIterable {
				case ios = "IOS"
				case macOs = "MAC_OS"
				case tvOs = "TV_OS"
				case visionOs = "VISION_OS"
			}

			public enum Sort: String, Codable, CaseIterable {
				case cfBundleVersion
				case minuscfBundleVersion = "-cfBundleVersion"
				case uploadedDate
				case minusuploadedDate = "-uploadedDate"
			}

			public enum FieldsBuildUploads: String, Codable, CaseIterable {
				case cfBundleShortVersionString
				case cfBundleVersion
				case createdDate
				case state
				case platform
				case uploadedDate
				case build
				case assetFile
				case assetDescriptionFile
				case assetSpiFile
				case buildUploadFiles
			}

			public enum FieldsBuilds: String, Codable, CaseIterable {
				case version
				case uploadedDate
				case expirationDate
				case expired
				case minOsVersion
				case lsMinimumSystemVersion
				case computedMinMacOsVersion
				case computedMinVisionOsVersion
				case iconAssetToken
				case processingState
				case buildAudienceType
				case usesNonExemptEncryption
				case preReleaseVersion
				case individualTesters
				case betaGroups
				case betaBuildLocalizations
				case appEncryptionDeclaration
				case betaAppReviewSubmission
				case app
				case buildBetaDetail
				case appStoreVersion
				case icons
				case buildBundles
				case buildUpload
				case perfPowerMetrics
				case diagnosticSignatures
			}

			public enum FieldsBuildUploadFiles: String, Codable, CaseIterable {
				case assetDeliveryState
				case assetToken
				case assetType
				case fileName
				case fileSize
				case sourceFileChecksums
				case uploadOperations
				case uti
			}

			public enum Include: String, Codable, CaseIterable {
				case build
				case assetFile
				case assetDescriptionFile
				case assetSpiFile
			}

			public init(filterCfBundleShortVersionString: [String]? = nil, filterCfBundleVersion: [String]? = nil, filterPlatform: [FilterPlatform]? = nil, filterState: [String]? = nil, sort: [Sort]? = nil, fieldsBuildUploads: [FieldsBuildUploads]? = nil, fieldsBuilds: [FieldsBuilds]? = nil, fieldsBuildUploadFiles: [FieldsBuildUploadFiles]? = nil, limit: Int? = nil, include: [Include]? = nil) {
				self.filterCfBundleShortVersionString = filterCfBundleShortVersionString
				self.filterCfBundleVersion = filterCfBundleVersion
				self.filterPlatform = filterPlatform
				self.filterState = filterState
				self.sort = sort
				self.fieldsBuildUploads = fieldsBuildUploads
				self.fieldsBuilds = fieldsBuilds
				self.fieldsBuildUploadFiles = fieldsBuildUploadFiles
				self.limit = limit
				self.include = include
			}

			public var asQuery: [(String, String?)] {
				let encoder = URLQueryEncoder(explode: false)
				encoder.encode(filterCfBundleShortVersionString, forKey: "filter[cfBundleShortVersionString]")
				encoder.encode(filterCfBundleVersion, forKey: "filter[cfBundleVersion]")
				encoder.encode(filterPlatform, forKey: "filter[platform]")
				encoder.encode(filterState, forKey: "filter[state]")
				encoder.encode(sort, forKey: "sort")
				encoder.encode(fieldsBuildUploads, forKey: "fields[buildUploads]")
				encoder.encode(fieldsBuilds, forKey: "fields[builds]")
				encoder.encode(fieldsBuildUploadFiles, forKey: "fields[buildUploadFiles]")
				encoder.encode(limit, forKey: "limit")
				encoder.encode(include, forKey: "include")
				return encoder.items
			}
		}
	}
}
