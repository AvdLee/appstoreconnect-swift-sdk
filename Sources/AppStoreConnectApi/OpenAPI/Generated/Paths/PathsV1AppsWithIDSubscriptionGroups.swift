// Generated by Create API
// https://github.com/CreateAPI/CreateAPI

import Foundation
import AppStoreConnectApiCore
import URLQueryEncoder

extension APIEndpoint.V1.Apps.WithID {
	public var subscriptionGroups: SubscriptionGroups {
		SubscriptionGroups(path: path + "/subscriptionGroups")
	}

	public struct SubscriptionGroups {
		/// Path: `/v1/apps/{id}/subscriptionGroups`
		public let path: String

		public func get(parameters: GetParameters? = nil) -> Request<AppStoreConnectApi.SubscriptionGroupsResponse> {
			Request(path: path, method: "GET", query: parameters?.asQuery, id: "apps_subscriptionGroups_getToManyRelated")
		}

		public struct GetParameters {
			public var filterReferenceName: [String]?
			public var filterSubscriptionsState: [FilterSubscriptionsState]?
			public var sort: [Sort]?
			public var fieldsSubscriptionGroups: [FieldsSubscriptionGroups]?
			public var fieldsSubscriptions: [FieldsSubscriptions]?
			public var fieldsSubscriptionGroupLocalizations: [FieldsSubscriptionGroupLocalizations]?
			public var limit: Int?
			public var include: [Include]?
			public var limitSubscriptions: Int?
			public var limitSubscriptionGroupLocalizations: Int?

			public enum FilterSubscriptionsState: String, Codable, CaseIterable {
				case missingMetadata = "MISSING_METADATA"
				case readyToSubmit = "READY_TO_SUBMIT"
				case waitingForReview = "WAITING_FOR_REVIEW"
				case inReview = "IN_REVIEW"
				case developerActionNeeded = "DEVELOPER_ACTION_NEEDED"
				case pendingBinaryApproval = "PENDING_BINARY_APPROVAL"
				case approved = "APPROVED"
				case developerRemovedFromSale = "DEVELOPER_REMOVED_FROM_SALE"
				case removedFromSale = "REMOVED_FROM_SALE"
				case rejected = "REJECTED"
			}

			public enum Sort: String, Codable, CaseIterable {
				case referenceName
				case minusreferenceName = "-referenceName"
			}

			public enum FieldsSubscriptionGroups: String, Codable, CaseIterable {
				case referenceName
				case subscriptions
				case subscriptionGroupLocalizations
			}

			public enum FieldsSubscriptions: String, Codable, CaseIterable {
				case name
				case productID = "productId"
				case familySharable
				case state
				case subscriptionPeriod
				case reviewNote
				case groupLevel
				case subscriptionLocalizations
				case appStoreReviewScreenshot
				case group
				case introductoryOffers
				case promotionalOffers
				case offerCodes
				case prices
				case pricePoints
				case promotedPurchase
				case subscriptionAvailability
				case winBackOffers
				case images
			}

			public enum FieldsSubscriptionGroupLocalizations: String, Codable, CaseIterable {
				case name
				case customAppName
				case locale
				case state
				case subscriptionGroup
			}

			public enum Include: String, Codable, CaseIterable {
				case subscriptions
				case subscriptionGroupLocalizations
			}

			public init(filterReferenceName: [String]? = nil, filterSubscriptionsState: [FilterSubscriptionsState]? = nil, sort: [Sort]? = nil, fieldsSubscriptionGroups: [FieldsSubscriptionGroups]? = nil, fieldsSubscriptions: [FieldsSubscriptions]? = nil, fieldsSubscriptionGroupLocalizations: [FieldsSubscriptionGroupLocalizations]? = nil, limit: Int? = nil, include: [Include]? = nil, limitSubscriptions: Int? = nil, limitSubscriptionGroupLocalizations: Int? = nil) {
				self.filterReferenceName = filterReferenceName
				self.filterSubscriptionsState = filterSubscriptionsState
				self.sort = sort
				self.fieldsSubscriptionGroups = fieldsSubscriptionGroups
				self.fieldsSubscriptions = fieldsSubscriptions
				self.fieldsSubscriptionGroupLocalizations = fieldsSubscriptionGroupLocalizations
				self.limit = limit
				self.include = include
				self.limitSubscriptions = limitSubscriptions
				self.limitSubscriptionGroupLocalizations = limitSubscriptionGroupLocalizations
			}

			public var asQuery: [(String, String?)] {
				let encoder = URLQueryEncoder(explode: false)
				encoder.encode(filterReferenceName, forKey: "filter[referenceName]")
				encoder.encode(filterSubscriptionsState, forKey: "filter[subscriptions.state]")
				encoder.encode(sort, forKey: "sort")
				encoder.encode(fieldsSubscriptionGroups, forKey: "fields[subscriptionGroups]")
				encoder.encode(fieldsSubscriptions, forKey: "fields[subscriptions]")
				encoder.encode(fieldsSubscriptionGroupLocalizations, forKey: "fields[subscriptionGroupLocalizations]")
				encoder.encode(limit, forKey: "limit")
				encoder.encode(include, forKey: "include")
				encoder.encode(limitSubscriptions, forKey: "limit[subscriptions]")
				encoder.encode(limitSubscriptionGroupLocalizations, forKey: "limit[subscriptionGroupLocalizations]")
				return encoder.items
			}
		}
	}
}
