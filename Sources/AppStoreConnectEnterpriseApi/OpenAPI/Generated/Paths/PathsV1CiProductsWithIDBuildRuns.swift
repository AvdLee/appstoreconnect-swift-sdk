// Generated by Create API
// https://github.com/CreateAPI/CreateAPI

import Foundation
import AppStoreConnectApiCore
import URLQueryEncoder

extension EnterpriseAPIEndpoint.V1.CiProducts.WithID {
	public var buildRuns: BuildRuns {
		BuildRuns(path: path + "/buildRuns")
	}

	public struct BuildRuns {
		/// Path: `/v1/ciProducts/{id}/buildRuns`
		public let path: String

		public func get(parameters: GetParameters? = nil) -> Request<AppStoreConnectEnterpriseApi.CiBuildRunsResponse> {
			Request(path: path, method: "GET", query: parameters?.asQuery, id: "ciProducts_buildRuns_getToManyRelated")
		}

		public struct GetParameters {
			public var filterBuilds: [String]?
			public var sort: [Sort]?
			public var fieldsCiBuildRuns: [FieldsCiBuildRuns]?
			public var fieldsBuilds: [FieldsBuilds]?
			public var fieldsCiWorkflows: [FieldsCiWorkflows]?
			public var fieldsCiProducts: [FieldsCiProducts]?
			public var fieldsScmGitReferences: [FieldsScmGitReferences]?
			public var fieldsScmPullRequests: [FieldsScmPullRequests]?
			public var limit: Int?
			public var include: [Include]?
			public var limitBuilds: Int?

			public enum Sort: String, Codable, CaseIterable {
				case number
				case minusnumber = "-number"
			}

			public enum FieldsCiBuildRuns: String, Codable, CaseIterable {
				case number
				case createdDate
				case startedDate
				case finishedDate
				case sourceCommit
				case destinationCommit
				case isPullRequestBuild
				case issueCounts
				case executionProgress
				case completionStatus
				case startReason
				case cancelReason
				case builds
				case workflow
				case product
				case sourceBranchOrTag
				case destinationBranch
				case actions
				case pullRequest
			}

			public enum FieldsBuilds: String, Codable, CaseIterable {
				case version
				case uploadedDate
				case expirationDate
				case expired
				case minOsVersion
				case lsMinimumSystemVersion
				case computedMinMacOsVersion
				case computedMinVisionOsVersion
				case iconAssetToken
				case processingState
				case buildAudienceType
				case usesNonExemptEncryption
				case preReleaseVersion
				case individualTesters
				case betaGroups
				case betaBuildLocalizations
				case appEncryptionDeclaration
				case betaAppReviewSubmission
				case app
				case buildBetaDetail
				case appStoreVersion
				case icons
				case buildBundles
				case perfPowerMetrics
				case diagnosticSignatures
			}

			public enum FieldsCiWorkflows: String, Codable, CaseIterable {
				case name
				case description
				case branchStartCondition
				case tagStartCondition
				case pullRequestStartCondition
				case scheduledStartCondition
				case manualBranchStartCondition
				case manualTagStartCondition
				case manualPullRequestStartCondition
				case actions
				case isEnabled
				case isLockedForEditing
				case clean
				case containerFilePath
				case lastModifiedDate
				case product
				case repository
				case xcodeVersion
				case macOsVersion
				case buildRuns
			}

			public enum FieldsCiProducts: String, Codable, CaseIterable {
				case name
				case createdDate
				case productType
				case app
				case bundleID = "bundleId"
				case workflows
				case primaryRepositories
				case additionalRepositories
				case buildRuns
			}

			public enum FieldsScmGitReferences: String, Codable, CaseIterable {
				case name
				case canonicalName
				case isDeleted
				case kind
				case repository
			}

			public enum FieldsScmPullRequests: String, Codable, CaseIterable {
				case title
				case number
				case webURL = "webUrl"
				case sourceRepositoryOwner
				case sourceRepositoryName
				case sourceBranchName
				case destinationRepositoryOwner
				case destinationRepositoryName
				case destinationBranchName
				case isClosed
				case isCrossRepository
				case repository
			}

			public enum Include: String, Codable, CaseIterable {
				case builds
				case workflow
				case product
				case sourceBranchOrTag
				case destinationBranch
				case pullRequest
			}

			public init(filterBuilds: [String]? = nil, sort: [Sort]? = nil, fieldsCiBuildRuns: [FieldsCiBuildRuns]? = nil, fieldsBuilds: [FieldsBuilds]? = nil, fieldsCiWorkflows: [FieldsCiWorkflows]? = nil, fieldsCiProducts: [FieldsCiProducts]? = nil, fieldsScmGitReferences: [FieldsScmGitReferences]? = nil, fieldsScmPullRequests: [FieldsScmPullRequests]? = nil, limit: Int? = nil, include: [Include]? = nil, limitBuilds: Int? = nil) {
				self.filterBuilds = filterBuilds
				self.sort = sort
				self.fieldsCiBuildRuns = fieldsCiBuildRuns
				self.fieldsBuilds = fieldsBuilds
				self.fieldsCiWorkflows = fieldsCiWorkflows
				self.fieldsCiProducts = fieldsCiProducts
				self.fieldsScmGitReferences = fieldsScmGitReferences
				self.fieldsScmPullRequests = fieldsScmPullRequests
				self.limit = limit
				self.include = include
				self.limitBuilds = limitBuilds
			}

			public var asQuery: [(String, String?)] {
				let encoder = URLQueryEncoder(explode: false)
				encoder.encode(filterBuilds, forKey: "filter[builds]")
				encoder.encode(sort, forKey: "sort")
				encoder.encode(fieldsCiBuildRuns, forKey: "fields[ciBuildRuns]")
				encoder.encode(fieldsBuilds, forKey: "fields[builds]")
				encoder.encode(fieldsCiWorkflows, forKey: "fields[ciWorkflows]")
				encoder.encode(fieldsCiProducts, forKey: "fields[ciProducts]")
				encoder.encode(fieldsScmGitReferences, forKey: "fields[scmGitReferences]")
				encoder.encode(fieldsScmPullRequests, forKey: "fields[scmPullRequests]")
				encoder.encode(limit, forKey: "limit")
				encoder.encode(include, forKey: "include")
				encoder.encode(limitBuilds, forKey: "limit[builds]")
				return encoder.items
			}
		}
	}
}
